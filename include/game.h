////////////////////////////////////////////////////////////
// Copyright (c) 2022
// Daniel Moune Computer Systems, Inc.
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all copies and
// that both that copyright notice and this permission notice appear
// in supporting documentation.  Engr Daniel Moune makes no
// representations about the suitability of this software for any
// purpose.  It is provided "as is" without express or implied warranty.
//
////////////////////////////////////////////////////////////

#ifndef TETRIS_GAME_H
#define TETRIS_GAME_H

#include <SFML/Graphics.hpp>
#include "brick.h"
#include "event.h"
#include "effects.h"
#include <queue>

using namespace sf;

namespace tetris
{

////////////////////////////////////////////////////////////
/// \brief The Game class is designed to initialize and to run the game.
///
/// This class represents the Game Engine and provides the default
/// service and functionalities for running the Game.
///
////////////////////////////////////////////////////////////
class Game
{
public:
////////////////////////////////////////////////////////////
/// \brief Default constructor.
///
/// This constructor creates the game object
/// and initialize its default settings.
///
////////////////////////////////////////////////////////////
    Game();
////////////////////////////////////////////////////////////
/// \brief runs the Game in an OpenGL window.
///
/// Use this function to run the Game 
/// after creating the Game object with the constructor.
///
////////////////////////////////////////////////////////////
    void run();

protected:
////////////////////////////////////////////////////////////
/// \brief Handles all events of the Game.
///
/// Use this function to call all event handlers.
///
////////////////////////////////////////////////////////////
void processEvents();
////////////////////////////////////////////////////////////
/// \brief Handles events captured by SFML Engime.
///
/// This function call different graphic events' handlers.
/// Graphic Events are captured by the Game Window.
/// They cay can be keyboard events, time events,
/// gamePad events. The handling of these events can generate
/// game events. You should not call this function directly. 
/// You should instead call the processEvents() function.
///
////////////////////////////////////////////////////////////
void processSfmlEvents();
////////////////////////////////////////////////////////////
/// \brief Handles events provided to the Game Engine.
///
/// Use this function to call different event handlers.
/// Game Events are generated by the SFML handlers or by the Game itself.
/// They can trigger the execution of some Game Rules.
/// You should not call this function directly. 
/// You should instead call the processEvents() function.
///
////////////////////////////////////////////////////////////
void processGameEvents();
void processBrickEvents();
////////////////////////////////////////////////////////////
/// \brief Updates game data after each event processing loop.
///
/// Use this function to update sprites position,
/// game scores and objects data in the background.
///
////////////////////////////////////////////////////////////
void update(Time);
////////////////////////////////////////////////////////////
/// \brief renders all sprites on the screen after each update.
///
/// Use this function in a loop in order to clear the window
/// and redraw all game sprites with their new data.
///
////////////////////////////////////////////////////////////
void render();
////////////////////////////////////////////////////////////
/// \brief renders the boundaries of the stage
///
/// Use this function to draw boundaries of the game's stage
/// sprites move would not overflow these boundaries
///
////////////////////////////////////////////////////////////
void renderBoundaries();
////////////////////////////////////////////////////////////
/// \brief calls keyboard event handlers according to the key received.
///
/// Use this function to define handlers for each of the keys
/// you would like the game to handle.
///
/// \param key   SFML key code e.g.  Keyboard::A designate keyboard "A" key value
/// \param isPressed   if TRUE the key is pressed else the key is not pressed
///
////////////////////////////////////////////////////////////
void handlePlayerInput(Keyboard::Key key, bool isPressed, Time time);
////////////////////////////////////////////////////////////
/// \brief pops any event in the event queue and returns it.
///
/// This function is not blocking. If no event is found in the event queue
/// it will return FALSE and the event parameter will return undefined. Otherwise it will return TRUE
///
/// \param event   Game event that would be returned
/// \return TRUE if an event was returned and FALSE if the event queue is empty.
///
////////////////////////////////////////////////////////////
bool pollGameEvent(Event& event);
////////////////////////////////////////////////////////////
/// \brief prints a message explaining the event to the console.
///
/// Use this function to track how the game handles events.
/// This function will print events message and the brick position on the console.
///
/// \param event   Game event that would be explained in the console.
///
////////////////////////////////////////////////////////////
void logEvent(Event event);

public:
    static const Time TimePerFrame; /// The amount of time the Game Engine has to wait before refreshing the Window
    static float PlayerSpeed; /// The amount of time the Game Engine has to wait before refreshing the Window

private:
    RenderWindow Window; ///< The OpenGL window used for game rendering
    Font font;                         ///< The Font used to render text in the game
    Text score_text;               ///< Text that will display the player's score
    Text next_text;                ///< Text that will display just "Next" to specfiy the next brick
    int n_rows_cleared;            ///< This is the total nbr of rows cleared by the player of the game
    Vector2u Area;                  ///< The game area where the player is allowed to move 
    Brick* Current;                  ///< The current brick manipulated by the Player
    Brick* Next;                       ///< The next brick to be dropped on the area when the Player would have placed the current one
    bool Render;                     ///< TRUE if it is time to render a frame on the window, FALSE if not
    bool NewDrop;                   ///< TRUE if it is time to Drop a new brick on the area , FALSE if not
    bool OutofBounds;          ///< TRUE if it is brick is positionned out of bounds, FALSE if not
    bool MovingUp;                 ///< TRUE if the KeyUP is pressed , FALSE if the KeyUP is released
    bool MovingDown;            ///< TRUE if the KeyDown is pressed , FALSE if the KeyDown is released
    bool MovingLeft;             ///< TRUE if the keyLeft is pressed , FALSE if the KeyLeft is released
    bool MovingRight;            ///< TRUE if the keyRight is pressed , FALSE if the KeyRight is released
    bool StartGame;              ///< TRUE if the game window just opened and the game start running
    bool QuitGame;               ///< TRUE if the game window is closed by the player
    std::queue<Event> eventsQ;
    Clock gClock;
};// class Game

} // namespace tetris

#endif // TETRIS_GAME_H